# 项目 2 | CS 61A 秋季 2021

**项目 2：CS 61A 自动纠错打字软件**

## 引言

> **重要提交说明：**
>
> 为了获得满分：
>
> *   在 **9月28日（星期二）** 前提交完成第一阶段的内容（占1分）。
> *   在 **10月1日（星期五）** 前提交完成所有阶段的内容。
>
> 尽管第一阶段的截止日期距离项目其余部分的截止日期只有几天，但您不应推迟完成第一阶段。我们建议尽快开始并完成第一阶段。
>
> 请尝试按顺序解决问题，因为一些后续问题在实现上（以及因此在运行 `ok` 测试时）会依赖于先前的问题。
>
> 整个项目可以与一位搭档共同完成。
>
> 您可以通过在 **9月30日（星期四）** 前提交整个项目来获得1个额外的奖励积分。

在本个项目中，您将编写一个测量打字速度的程序。此外，您还将实现打字自动纠错功能，该功能会在用户输入单词后尝试纠正拼写错误。本项目的灵感来源于 [typeracer](https://play.typeracer.com/)。

> 过去，当学生们试图在没有彻底阅读问题描述的情况下实现功能时，他们经常会遇到问题。 😱
> **在开始编码之前，请仔细阅读每个描述。**

## 最终产品

我们的项目参考解决方案可以在 [cats.cs61a.org](https://cats.cs61a.org) 上进行交互。如果您愿意，可以现在就尝试一下。完成项目后，您将自己实现这个比赛的很大一部分！

## 下载起始文件

您可以将所有项目代码下载为一个 [zip 压缩包](cats.zip)。本项目包含多个文件，但您只需要修改 `cats.py` 文件。以下是压缩包中包含的文件：

*   `cats.py`: 打字测试逻辑。
*   `utils.py`: 用于与文件和字符串交互的实用函数。
*   `ucb.py`: CS 61A 项目的实用函数。
*   `data/sample_paragraphs.txt`: 包含用于打字的文本样本的文件。这些是从维基百科上关于各种主题的文章中[抓取](https://github.com/kavigupta/wikivideos/blob/626de521e04ca643751ed85d549faca6ea528b1d/get_corpus.py)的。
*   `data/common_words.txt`: 包含按频率排序的常见[英语单词](https://github.com/first20hours/google-10000-english/blob/master/google-10000-english-usa-no-swears.txt)的文件。
*   `data/words.txt`: 包含更多按频率排序的[英语单词](https://github.com/first20hours/google-10000-english/blob/master/google-10000-english-usa-no-swears.txt)的文件。
*   `cats_gui.py`: 用于基于 Web 的图形用户界面 (GUI) 的 Web 服务器。
*   `gui_files`: 图形用户界面 (GUI) 所需文件的目录。
*   `multiplayer`: 支持多人模式所需文件的目录。
*   `favicons`: 图标目录。
*   `images`: 图片目录。
*   `ok`, `proj02.ok`, `tests`: 测试文件。

## 项目安排

> 项目总共20分。
> 其中17分用于考察正确性，
> 2分用于考察代码风格，
> 1分用于在检查点截止日期前提交第一阶段。

您需要提交以下文件：

*   `cats.py`

您不需要修改或提交任何其他文件来完成此项目。要提交项目，请运行以下命令：

```
python3 ok --submit
```

您可以在 [Ok dashboard](http://ok.cs61a.org) 上查看您的提交。

对于我们要求您完成的函数，我们可能会提供一些初始代码。如果您不想使用这些代码，可以随意删除并从头开始。您也可以根据需要添加新的函数定义。

但是，请**不要**修改任何其他函数。这样做可能会导致您的代码无法通过我们的自动评分测试。另外，请不要更改任何函数签名（名称、参数顺序或参数数量）。

在整个项目中，您应该测试代码的正确性。经常测试是一个好习惯，这样可以轻松地找出任何问题。但是，您不应该测试*过于*频繁，以便给自己留出时间思考问题。

我们提供了一个名为 `ok` 的**自动评分器**，以帮助您测试代码并跟踪进度。第一次运行自动评分器时，系统会要求您**使用网络浏览器登录您的 Ok 帐户**。请照做。每次运行 `ok` 时，它都会在我们的服务器上备份您的工作和进度。

`ok` 的主要目的是测试您的实现。

我们建议您在**完成每个问题后**提交。只有您的最后一次提交会被评分。拥有更多代码备份对我们来说也很有用，以防您遇到提交问题。**如果您忘记提交，您的最后一次备份将自动转换为提交。**

如果您不希望我们记录您的工作备份或进度信息，可以运行：
```
python3 ok --local
```
使用此选项，任何信息都不会发送到我们的课程服务器。

如果您想交互式地测试您的代码，可以运行：
```
python3 ok -q [问题编号] -i
```
并插入相应的问题编号（例如 `01`）。这将运行该问题的测试，直到第一个失败的测试，然后让您有机会交互式地测试您编写的函数。

您还可以在 OK 中使用调试打印功能，方法是编写：
```
print("DEBUG:", x)
```
这将在您的终端中产生输出，而不会导致 OK 测试因额外输出而失败。



# 第一阶段：打字

> 过去，当学生们试图在没有彻底阅读问题描述的情况下实现功能时，他们经常会遇到问题。 😱
> **在开始编码之前，请仔细阅读每个描述。**

### 问题 1 (1 分)

在整个项目中，我们将对 `cats.py` 中的函数进行更改。

实现 `choose` 函数。此函数选择用户将要输入的段落。它接受三个参数：

*   一个 `paragraphs` (字符串) 列表
*   一个 `select` 函数，对于可以选择的段落，该函数返回 `True`
*   一个非负索引 `k`

`choose` 函数返回 `select` 函数返回 `True` 的第 `k` 个段落。如果不存在这样的段落（因为 `k` 太大），则 `choose` 返回空字符串。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 01 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 01
```

### 问题 2 (1 分)

实现 `about` 函数，它接受一个 `topic` 单词列表。它返回一个函数，该函数接受一个段落并返回一个布尔值，指示该段落是否包含 `topic` 中的任何单词。

一旦我们实现了 `about`，我们就能将返回的函数作为 `select` 参数传递给 `choose`，这在我们继续实现打字测试时会很有用。

为了能够准确地进行比较，您需要忽略段落中的大小写（即，假设大写和小写字母不会改变单词本身）和标点符号。此外，只检查段落中 `topic` 中单词的精确匹配，而不是子字符串。例如，“dogs”与单词“dog”不匹配。

> **提示**：
> 您可以使用 `utils.py` 中的字符串实用函数。
> 您可以参考实用函数的文档字符串来了解它们的使用方法。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 02 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 02
```

### 问题 3 (2 分)

实现 `accuracy` 函数，它接受一个 `typed` 段落和一个 `reference` 段落。它返回 `typed` 段落中与 `reference` 段落中相应单词完全匹配的单词百分比。大小写和标点符号也必须匹配。“相应”在这里意味着两个单词必须在 `typed` 和 `reference` 中以相同的索引出现——两者的第一个单词必须匹配，两者的第二个单词必须匹配，依此类推。

在此上下文中，*单词*是由空格与其他单词分隔开的任何字符序列，因此将“dog;”视为单个单词。

如果 `typed` 比 `reference` 长，则 `typed` 中没有相应 `reference` 单词的多余单词都算作不正确。

如果 `typed` 和 `reference` 都为空，则准确率为 100.0。
如果 `typed` 为空但 `reference` 不为空，则准确率为零。
如果 `typed` 不为空但 `reference` 为空，则准确率为零。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 03 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 03
```

👩🏽‍💻👨🏿‍💻 [结对编程？](../../articles/pair-programming)
记住轮流担任驾驶员和导航员的角色。
驾驶员控制键盘；
导航员观察、提问并提出想法。

### 问题 4 (1 分)

实现 `wpm` 函数，该函数根据输入的字符串 `typed` 和经过的时间 `elapsed`（单位为**秒**）计算*每分钟字数* (words per minute)，这是一种衡量打字速度的指标。尽管名为*每分钟字数*，但它并非基于输入的单词数量，而是基于5个字符为一组的数量，这样打字测试就不会因单词长度而产生偏差。*每分钟字数*的计算公式是：输入的字符数（包括空格）除以5（典型单词长度），再除以经过的时间（单位为**分钟**）。

例如，字符串 `"I am glad!"` 包含三个单词和十个字符（不包括引号）。每分钟字数计算使用2作为输入的单词数（因为 10 / 5 = 2）。如果某人在30秒（半分钟）内输入此字符串，则其速度为每分钟4个单词。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 04 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 04
```

**是时候测试您的打字速度了！** 您可以使用命令行测试您在特定主题段落上的打字速度。例如，以下命令将加载关于猫或小猫的段落。如果您好奇，可以查看 `run_typing_test` 函数的实现（但它已为您定义）。

```
python3 cats.py -t cats kittens
```

您可以使用以下命令尝试基于 Web 的图形用户界面 (GUI)。
（在关闭浏览器中的选项卡后，您可能需要在终端上使用 `Ctrl+C` 或 `Cmd+C` 来退出 GUI）。

```
python3 cats_gui.py
```

**要提交您的第一阶段检查点**，请输入：
```
python3 ok --submit
```
在完成整个项目后，您可以再次提交，我们将只对您最新的提交进行评分，但请至少在检查点截止日期前提交一次（至少完成第一阶段的问题后），以获得检查点学分。

👩🏽‍💻👨🏿‍💻 [结对编程？](../../articles/pair-programming)
现在是交换角色的好时机。
交换角色可以确保
你们都能从担任每个角色的学习经验中受益。

# 第二阶段：自动纠错

> 过去，当学生们试图在没有彻底阅读问题描述的情况下实现功能时，他们经常会遇到问题。 😱
> **在开始编码之前，请仔细阅读每个描述。**

在基于 Web 的 GUI 中，有一个自动纠错按钮，但目前它不起作用。让我们来实现打字错误的自动纠错功能。每当用户按下空格键时，如果他们输入的最后一个单词与词典中的单词不匹配，但与某个单词很接近，那么该相似单词将替换他们输入的内容。

### 问题 5 (2 分)

实现 `autocorrect` 函数，它接受一个 `typed_word`（输入的单词）、一个 `valid_words`（所有有效单词的列表）、一个 `diff_function`（差异函数）和一个 `limit`（限制值）。

如果 `typed_word` 包含在 `valid_words` 列表中，`autocorrect` 返回该单词。

*否则*，`autocorrect` 返回 `valid_words` 中与提供的 `typed_word` 基于 `diff_function` 差异最小的单词。但是，如果 `typed_word` 与任何 `valid_words` 之间的最小差异大于 `limit`，则返回 `typed_word` 本身。

> **重要提示**：
> 如果 `typed_word` 不包含在 `valid_words` 中，并且根据 `diff_function`，有多个字符串与 `typed_word` 的差异相同且最小，则 `autocorrect` 应返回在 `valid_words` 中首先出现的字符串。

差异函数接受三个参数。前两个参数是要比较的两个字符串（`typed_word` 和来自 `valid_words` 的单词），第三个参数是 `limit`。差异函数的输出是一个数字，表示两个字符串之间的差异程度。

以下是一个差异函数的示例，它计算 `1 + limit` 与两个输入字符串长度差的最小值：

```python
>>> def length_diff(w1, w2, limit):
...     return min(limit + 1, abs(len(w2) - len(w1)))
>>> length_diff('mellow', 'cello', 10)
1
>>> length_diff('hippo', 'hippopotamus', 5)
6
```

假设 `typed_word` 和 `valid_words` 的所有元素都是小写字母且没有标点符号。

> **提示**：
> 尝试使用带有可选 `key` 参数的 `max` 或 `min` 函数。
> 有关使用此参数的一些示例，请查看9月22日（星期三）的讲座幻灯片。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 05 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 05
```

### 问题 6 (2 分)

实现 `feline_flips`，这是一个差异函数，它接受两个字符串。它返回将 `start` 单词转换为 `goal` 单词所需更改的最少字符数。如果字符串长度不相等，则长度差将加到总数中。

> **重要提示**：
> 在您的实现中，您不能使用 `while`、`for` 或列表推导式。
> 请使用递归。

以下是一些示例：
```python
>>> big_limit = 10
>>> feline_flips("nice", "rice", big_limit)    # 替换: n -> r
1
>>> feline_flips("range", "rungs", big_limit)  # 替换: a -> u, e -> s
2
>>> feline_flips("pill", "pillage", big_limit) # 不替换任何内容，长度差为3。
3
>>> feline_flips("roses", "arose", big_limit)  # 替换: r -> a, o -> r, s -> o, e -> s, s -> e
5
>>> feline_flips("rose", "hello", big_limit)   # 替换: r->h, o->e, s->l, e->l, 长度差为1。
5
```

> **重要提示：**
> 如果必须更改的字符数大于 `limit`，
> 则 `feline_flips` 应返回任何大于 `limit` 的数字，
> 并且应最小化执行此操作所需的计算量。
>
> 这两个对 `feline_flips` 的调用应该花费大致相同的时间来评估：
> ```python
> >>> limit = 4
> >>> feline_flips("roses", "arose", limit) > limit
> True
> >>> feline_flips("rosesabcdefghijklm", "arosenopqrstuvwxyz", limit) > limit
> True
> ```

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 06 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 06
```

尝试在 GUI 中打开自动纠错。它能帮助您更快地打字吗？纠错准确吗？您应该注意到，在单词开头附近插入或遗漏一个字母时，此差异函数处理得不是很好。让我们来修复它！

### 问题 7 (2 分)

实现 `minimum_mewtations`，这是一个差异函数，返回将 `start` 单词转换为 `goal` 单词所需的最少编辑操作次数。

有三种编辑操作，并附带一些示例：

1.  向 `start` 添加一个字母。
    *   向 `"itten"` 添加 `"k"` 得到 `"kitten"`。
2.  从 `start` 中删除一个字母。
    *   从 `"scat"` 中删除 `"s"` 得到 `"cat"`。
3.  将 `start` 中的一个字母替换为另一个字母。
    *   将 `"zaguar"` 中的 `"z"` 替换为 `"j"` 得到 `"jaguar"`。

每个编辑操作都会使两个单词之间的差异增加1。
```python
>>> big_limit = 10
>>> minimum_mewtations("cats", "scat", big_limit)       # cats -> scats -> scat
2
>>> minimum_mewtations("purng", "purring", big_limit)   # purng -> purrng -> purring
2
>>> minimum_mewtations("ckiteus", "kittens", big_limit) # ckiteus -> kiteus -> kitteus -> kittens
3
```

我们在 `cats.py` 中提供了一个实现模板。

> **提示：**
> 这是一个包含三个递归调用的递归函数。
> 其中一个递归调用将类似于 `feline_flips` 中的递归调用。

您可以根据需要修改模板，或者完全删除它。

> **重要提示：**
> 如果所需的编辑次数大于 `limit`，
> 则 `minimum_mewtations` 应返回任何大于 `limit` 的数字，
> 并且应最小化执行此操作所需的计算量。
>
> 这两个对 `minimum_mewtations` 的调用应该花费大致相同的时间来评估：
> ```python
> >>> limit = 2
> >>> minimum_mewtations("ckiteus", "kittens", limit) > limit
> True
> >>> minimum_mewtations("ckiteusabcdefghijklm", "kittensnopqrstuvwxyz", limit) > limit
> True
> ```

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 07 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 07
```

再试一次打字。纠错更准确了吗？
```
python3 cats_gui.py
```

👩🏽‍💻👨🏿‍💻 [结对编程？](../../articles/pair-programming)
庆祝一下，休息一下，然后交换角色！

### (可选) 扩展：最终差异 (0分)

您可以选择设计自己的差异函数，名为 `final_diff`。以下是一些使纠错更准确的想法：

*   考虑哪些添加和删除比其他更可能发生。例如，如果一个字母连续出现两次，您意外遗漏它的可能性要大得多。
*   将两个交换了位置的相邻字母视为一次更改，而不是两次。
*   尝试包含常见的拼写错误。

您还可以通过更改 `cats.py` 中变量 `FINAL_DIFF_LIMIT` 的值来设置您希望差异函数使用的限制。

您可以通过运行以下命令来检查您的 `final_diff` 的成功率：
```
python3 score.py
```

如果您不知道从哪里开始，可以尝试将您为 `feline_flips` 和 `minimum_mewtations` 编写的代码复制粘贴到 `final_diff` 中并对它们进行评分。查看它们意外修复的拼写错误可能会给您一些启发！

# 第三阶段：多人游戏

> 过去，当学生们试图在没有彻底阅读问题描述的情况下实现功能时，他们经常会遇到问题。 😱
> **在开始编码之前，请仔细阅读每个描述。**

和朋友一起打字更有趣！您现在将实现多人游戏功能，这样当您在计算机上运行 `cats_gui.py` 时，它会连接到课程服务器 [cats.cs61a.org](https://cats.cs61a.org) 并寻找其他人进行比赛。

要与朋友比赛，需要运行5个不同的程序：

*   您的 GUI，这是一个在 Web 浏览器中处理所有文本着色和显示的程序。
*   您的 `cats_gui.py`，这是一个 Web 服务器，使用您在 `cats.py` 中编写的代码与您的 GUI 通信。
*   您对手的 `cats_gui.py`。
*   您对手的 GUI。
*   CS 61A 多人游戏服务器，它将玩家匹配在一起并传递消息。

当您打字时，您的 GUI 会将您输入的内容上传到您的 `cats_gui.py` 服务器，该服务器会计算您的进度并返回进度更新。它还会将进度更新上传到多人游戏服务器，以便您对手的 GUI 可以显示它。

同时，您的 GUI 显示会一直尝试通过向 `cats_gui.py` 请求进度更新来保持最新状态，而 `cats_gui.py` 又会从多人游戏服务器请求该信息。

每个玩家都有一个 `id` 号码，服务器使用该号码来跟踪打字进度。

### 问题 8 (2 分)

实现 `report_progress` 函数，该函数在用户每次完成输入一个单词时调用。它接受一个已输入单词列表 `sofar`、提示单词列表 `prompt`、用户的 `user_id` 以及一个用于向多人游戏服务器上传进度报告的 `upload` 函数。`sofar` 中的单词数量永远不会超过 `prompt` 中的单词数量。

您的进度是您在 `prompt` 中正确输入的单词（直到第一个错误单词为止）与 `prompt` 单词总数的比率。例如，以下示例的进度为 `0.25`：
```
report_progress(["Hello", "ths", "is"], ["Hello", "this", "is", "wrong"], ...)
```

您的 `report_progress` 函数应该做两件事：向多人游戏服务器上传一条消息，并返回具有 `user_id` 的玩家的进度。

您可以通过调用 `upload` 函数并传入一个包含键 `'id'` 和 `'progress'` 的双元素字典来向多人游戏服务器上传消息。然后，您应该返回玩家的进度，即您计算的比率。

> **提示**：
> 请参阅下面的字典，作为 `upload` 函数潜在输入的示例。
> 此字典表示 `user_id` 为 1 且 `progress` 为 0.6 的玩家。
>
> `{'id': 1, 'progress': 0.6}`

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 08 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 08
```

### 问题 9 (2 分)

实现 `time_per_word` 函数，该函数接受一个单词列表 `words` 和 `times_per_player`，后者是一个包含每个玩家完成输入 `words` 中每个单词的时间戳的列表的列表。它返回一个包含给定信息的 `match` 对象。

`match` 是一个数据抽象，包含一个 `words` 列表和一个 `times` 列表。`times` 存储为一个列表的列表，其中包含每个玩家输入 `words` 中每个单词所花费的时间。具体来说，`times[i][j]` 表示玩家 `i` 输入 `words[j]` 所花费的时间。

例如，假设 `words = ['Hello', 'world']` 且 `times = [[5, 1], [4, 2]]`，那么 `[5, 1]` 对应玩家 0 的时间列表，`[4, 2]` 对应玩家 1 的时间列表。因此，玩家 0 花了 `5` 个时间单位来输入单词 `'Hello'`。

> **重要提示**：
> 返回 `match` 时，请务必使用 `match` 构造函数。
> 测试将检查您是否正在使用数据抽象，而不是假设特定的数据格式。
>
> 阅读 `cats.py` 中 `match` 构造函数和选择器的定义，以了解有关数据抽象如何实现的更多信息。

时间戳是累积的且始终递增的，而 `times` 中的值是**每个玩家连续时间戳之间的差值**。

以下是一个示例：
如果 `times_per_player = [[1, 3, 5], [2, 5, 6]]`，则 `match` 的相应 `times` 属性将是 `[[2,2], [3, 1]]`。
这是因为时间戳的差值对于第一个玩家是 `(3-1)`、`(5-3)`，对于第二个玩家是 `(5-2)`、`(6-5)`。
`times_per_player` 中每个列表的第一个值表示每个玩家的初始开始时间。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 09 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 09
```

👩🏽‍💻👨🏿‍💻 [结对编程？](../../articles/pair-programming)
如果您最近没有交换角色，我们建议现在交换。快完成了！

### 问题 10 (2 分)

实现 `fastest_words` 函数，该函数返回每个玩家输入最快的单词。此函数在两个玩家都完成输入后调用一次。它接受一个 `match` 对象。

具体来说，`fastest_words` 函数返回一个单词列表的列表，每个玩家一个列表，每个列表中包含他们输入最快的单词（与所有其他玩家相比）。如果出现平局，则认为列表中最早的玩家（玩家索引最小的）输入得最快。

例如，考虑以下包含单词 'Just'、'have' 和 'fun' 的比赛。玩家 0 输入 'fun' 最快（3 秒），玩家 1 输入 'Just' 最快（4 秒），他们在单词 'have' 上打平（都用了 1 秒），因此我们认为玩家 0 最快，因为他们是列表中最早的玩家。

```python
>>> player_0 = [5, 1, 3]
>>> player_1 = [4, 1, 6]
>>> fastest_words(match(['Just', 'have', 'fun'], [player_0, player_1]))
[['have', 'fun'], ['Just']]
```

`match` 参数是一个 `match` 数据抽象，就像问题9中返回的那样。您可以使用选择器 `word_at` 访问 `match` 中的单词，该选择器接受一个 `match` 和 `word_index`（一个整数）。使用 `word_at`，您可以使用 `time` 访问任何玩家输入任何单词所花费的时间。

> **重要提示**：
> 返回 `match` 时，请务必使用 `match` 构造函数。
> 测试将检查您是否正在使用数据抽象，而不是假设特定的数据格式。
>
> 确保您的实现不会改变给定的玩家输入列表。
> 对于上面的示例，在 `[player_0, player_1]` 上调用 `fastest_words`
> **不应**改变 `player_0` 或 `player_1`。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```
python3 ok -q 10 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查其正确性：
```
python3 ok -q 10
```

恭喜！现在您可以与课程中的其他学生对战了。在 `cats.py` 底部附近将 `enable_multiplayer` 设置为 `True`，然后快速打字吧！
```
python3 cats_gui.py
```

此时，运行整个自动评分器，看看是否有任何测试未通过。
```
python3 ok
```

满意后，提交到 Ok 以完成项目。
```
python3 ok --submit
```

如果您有搭档，请确保在 [okpy](https://okpy.org/) 上的提交中添加他们。

通过运行以下命令检查以确保您完成了所有问题：
```
python3 ok --score
```
